# OpenRisk 게시판 기능 구현 계획

> 작성일: 2026-01-06
> 구현 완료: 2026-01-07
> 상태: ✅ Phase 1~5 완료, Phase 6 (관리자 설정) 대기

---

## 요구사항 요약

| 항목 | 내용 |
|------|------|
| 로그인 | 카카오 OAuth |
| 게시판 | 관리자 공지 + 사용자 글 (단일 게시판) |
| 댓글 | 글에 대한 댓글 기능 |
| UI | Skin-B 스타일 (신문 스타일) |

---

## 1. Supabase 사전 설정

### 1.1 카카오 OAuth 설정

1. **Supabase Dashboard** > Authentication > Providers > Kakao 활성화
2. **카카오 개발자 콘솔**에서:
   - REST API 키 복사
   - Redirect URI 추가: `https://[project-id].supabase.co/auth/v1/callback`
3. Supabase에 REST API 키 입력

### 1.2 데이터베이스 테이블 생성

```sql
-- ============================================
-- OpenRisk 게시판 스키마 v2.0
-- 보안 리뷰 반영: soft delete 통일, RLS OR 이슈 해결,
-- 컬럼 권한, RPC 보안, 뷰 기반 쿼리
-- ============================================

-- 1. profiles 테이블 (Supabase Auth 연동)
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  kakao_id TEXT UNIQUE,  -- BIGINT → TEXT (안전한 타입)
  nickname TEXT NOT NULL,
  profile_image TEXT,
  is_admin BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. posts 테이블
CREATE TABLE public.posts (
  id SERIAL PRIMARY KEY,
  author_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  is_notice BOOLEAN DEFAULT false,
  view_count INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ DEFAULT NULL  -- Soft Delete용
);

-- 3. comments 테이블
CREATE TABLE public.comments (
  id SERIAL PRIMARY KEY,
  post_id INTEGER NOT NULL REFERENCES public.posts(id) ON DELETE CASCADE,
  author_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  deleted_at TIMESTAMPTZ DEFAULT NULL  -- Soft Delete용
);

-- 4. blocked_users 테이블 (차단 관리)
CREATE TABLE public.blocked_users (
  id SERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  reason TEXT,
  blocked_at TIMESTAMPTZ DEFAULT NOW(),
  blocked_until TIMESTAMPTZ  -- NULL이면 영구 차단
);

-- 5. reports 테이블 (신고 관리)
CREATE TABLE public.reports (
  id SERIAL PRIMARY KEY,
  reporter_id UUID NOT NULL REFERENCES public.profiles(id),
  post_id INTEGER REFERENCES public.posts(id),
  comment_id INTEGER REFERENCES public.comments(id),
  reason TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  CONSTRAINT report_target_check CHECK (
    (post_id IS NOT NULL AND comment_id IS NULL) OR
    (post_id IS NULL AND comment_id IS NOT NULL)
  )
);

-- ============================================
-- 인덱스 (페이지네이션/정렬 성능)
-- ============================================
CREATE INDEX idx_posts_list ON public.posts(is_notice DESC, created_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_posts_author ON public.posts(author_id, created_at DESC);
CREATE INDEX idx_comments_post ON public.comments(post_id, created_at ASC) WHERE deleted_at IS NULL;
CREATE INDEX idx_blocked_users_check ON public.blocked_users(user_id, blocked_until);

-- ============================================
-- 뷰 (Soft Delete된 항목 제외 - RLS 정책 꼬임 방지)
-- 앱에서는 이 뷰만 사용
-- ============================================
CREATE VIEW public.active_posts AS
SELECT p.*,
       pr.nickname AS author_nickname,
       pr.profile_image AS author_profile_image,
       pr.is_admin AS author_is_admin,
       (SELECT COUNT(*) FROM public.comments c WHERE c.post_id = p.id AND c.deleted_at IS NULL) AS comment_count
FROM public.posts p
JOIN public.profiles pr ON p.author_id = pr.id
WHERE p.deleted_at IS NULL;

CREATE VIEW public.active_comments AS
SELECT c.*,
       pr.nickname AS author_nickname,
       pr.profile_image AS author_profile_image,
       pr.is_admin AS author_is_admin
FROM public.comments c
JOIN public.profiles pr ON c.author_id = pr.id
WHERE c.deleted_at IS NULL;

-- ============================================
-- updated_at 자동 갱신 트리거
-- ============================================
CREATE OR REPLACE FUNCTION public.update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  -- view_count만 변경된 경우 updated_at 갱신 제외
  IF TG_TABLE_NAME = 'posts' AND
     OLD.title = NEW.title AND
     OLD.content = NEW.content AND
     OLD.is_notice = NEW.is_notice AND
     OLD.deleted_at IS NOT DISTINCT FROM NEW.deleted_at THEN
    RETURN NEW;
  END IF;

  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER posts_updated_at
  BEFORE UPDATE ON public.posts
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

CREATE TRIGGER comments_updated_at
  BEFORE UPDATE ON public.comments
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();

-- ============================================
-- RLS 정책
-- ============================================
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.blocked_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reports ENABLE ROW LEVEL SECURITY;

-- ============================================
-- profiles RLS
-- is_admin 변경 방지는 컬럼 권한으로 처리 (아래 REVOKE/GRANT)
-- ============================================
CREATE POLICY "profiles_select" ON public.profiles
  FOR SELECT USING (true);

CREATE POLICY "profiles_insert" ON public.profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

CREATE POLICY "profiles_update" ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

-- ============================================
-- posts RLS
-- DELETE 정책 제거 (soft delete만 허용)
-- 차단 체크를 INSERT/UPDATE에 통합 (OR 이슈 방지)
-- ============================================
CREATE POLICY "posts_select" ON public.posts
  FOR SELECT USING (true);  -- 뷰에서 deleted_at 필터링

CREATE POLICY "posts_insert" ON public.posts
  FOR INSERT WITH CHECK (
    auth.uid() = author_id
    AND (
      is_notice = false
      OR EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
    )
    AND NOT EXISTS (
      SELECT 1 FROM public.blocked_users
      WHERE user_id = auth.uid()
      AND (blocked_until IS NULL OR blocked_until > NOW())
    )
  );

CREATE POLICY "posts_update" ON public.posts
  FOR UPDATE
  USING (
    auth.uid() = author_id
    OR EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  )
  WITH CHECK (
    auth.uid() = author_id
    AND (
      is_notice = false
      OR EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
    )
  );

-- DELETE 정책 없음 (soft delete만 허용)

-- ============================================
-- comments RLS
-- ============================================
CREATE POLICY "comments_select" ON public.comments
  FOR SELECT USING (true);  -- 뷰에서 deleted_at 필터링

CREATE POLICY "comments_insert" ON public.comments
  FOR INSERT WITH CHECK (
    auth.uid() = author_id
    AND NOT EXISTS (
      SELECT 1 FROM public.blocked_users
      WHERE user_id = auth.uid()
      AND (blocked_until IS NULL OR blocked_until > NOW())
    )
  );

CREATE POLICY "comments_update" ON public.comments
  FOR UPDATE
  USING (
    auth.uid() = author_id
    OR EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );

-- DELETE 정책 없음 (soft delete만 허용)

-- ============================================
-- blocked_users RLS (관리자만)
-- ============================================
CREATE POLICY "blocked_users_admin" ON public.blocked_users
  FOR ALL USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );

-- ============================================
-- reports RLS
-- ============================================
CREATE POLICY "reports_insert" ON public.reports
  FOR INSERT WITH CHECK (auth.uid() = reporter_id);

CREATE POLICY "reports_select_admin" ON public.reports
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM public.profiles WHERE id = auth.uid() AND is_admin = true)
  );

-- ============================================
-- 컬럼 권한: is_admin 변경 방지
-- authenticated 역할에서 is_admin 업데이트 불가
-- ============================================
REVOKE UPDATE (is_admin) ON public.profiles FROM authenticated;

-- ============================================
-- view_count RPC (보안 강화)
-- search_path 설정 + 실행 권한 제한
-- ============================================
CREATE OR REPLACE FUNCTION public.increment_view_count(p_post_id INTEGER)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''  -- 보안: search_path 고정
AS $$
BEGIN
  UPDATE public.posts
  SET view_count = view_count + 1
  WHERE id = p_post_id AND deleted_at IS NULL;
END;
$$;

-- 기본 실행 권한 제거 후 service_role만 허용
REVOKE EXECUTE ON FUNCTION public.increment_view_count(INTEGER) FROM PUBLIC;
REVOKE EXECUTE ON FUNCTION public.increment_view_count(INTEGER) FROM authenticated;
GRANT EXECUTE ON FUNCTION public.increment_view_count(INTEGER) TO service_role;

-- ============================================
-- 신규 사용자 프로필 자동 생성 트리거
-- kakao_id를 TEXT로 안전하게 저장
-- ============================================
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  v_kakao_id TEXT;
  v_nickname TEXT;
  v_avatar TEXT;
BEGIN
  -- 카카오 메타데이터 안전하게 추출 (TEXT로 저장)
  v_kakao_id := NEW.raw_user_meta_data->>'provider_id';
  v_nickname := COALESCE(
    NEW.raw_user_meta_data->>'name',
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'nickname',
    '익명'
  );
  v_avatar := COALESCE(
    NEW.raw_user_meta_data->>'avatar_url',
    NEW.raw_user_meta_data->>'picture',
    NEW.raw_user_meta_data->>'profile_image'
  );

  INSERT INTO public.profiles (id, kakao_id, nickname, profile_image)
  VALUES (NEW.id, v_kakao_id, v_nickname, v_avatar);

  RETURN NEW;
EXCEPTION
  WHEN OTHERS THEN
    -- 프로필 생성 실패해도 회원가입은 진행 (로그만 남김)
    RAISE WARNING 'Failed to create profile for user %: %', NEW.id, SQLERRM;
    RETURN NEW;
END;
$$;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();
```

---

## 2. 파일 구조

```
lib/
  supabase-auth.ts          # 신규: 인증 클라이언트

app/
  auth/
    callback/route.ts       # OAuth 콜백
  board/
    page.tsx                # 게시판 목록
    write/page.tsx          # 글 작성
    [id]/page.tsx           # 글 상세 + 댓글

  api/board/
    posts/route.ts          # GET 목록, POST 작성
    posts/[id]/route.ts     # GET 상세, PUT 수정, DELETE 삭제
    comments/route.ts       # POST 댓글 작성
    comments/[id]/route.ts  # DELETE 댓글 삭제

components/board/
  AuthButton.tsx            # 카카오 로그인/로그아웃
  PostList.tsx              # 게시글 목록
  PostForm.tsx              # 글 작성/수정 폼
  CommentSection.tsx        # 댓글 목록 + 작성
```

---

## 3. 구현 순서

### Step 1: 패키지 설치
```bash
npm install @supabase/ssr @supabase/supabase-js
```

### Step 2: Supabase SSR 설정 (미들웨어 포함)

#### 2.1 환경 변수 설정
```bash
# .env.local
NEXT_PUBLIC_SUPABASE_URL=https://[project-id].supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJ...
SUPABASE_SERVICE_ROLE_KEY=eyJ...  # 서버 전용 (절대 노출 금지)
```

#### 2.2 Supabase 클라이언트 유틸리티

```typescript
// lib/supabase/client.ts (브라우저용)
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}

// lib/supabase/server.ts (서버 컴포넌트/라우트용)
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            )
          } catch {
            // Server Component에서 호출 시 무시
          }
        },
      },
    }
  )
}

// lib/supabase/admin.ts (service_role용 - 서버만!)
import { createClient } from '@supabase/supabase-js'

export function createAdminClient() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    { auth: { persistSession: false } }
  )
}
```

#### 2.3 미들웨어 (세션 프록시)

```typescript
// middleware.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll()
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({
            request,
          })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // 중요: getSession()이 아닌 getUser()로 검증
  // getSession()은 쿠키 기반이라 조작 가능
  const { data: { user } } = await supabase.auth.getUser()

  // 보호된 경로 체크
  if (request.nextUrl.pathname.startsWith('/board/write') && !user) {
    const url = request.nextUrl.clone()
    url.pathname = '/board'
    url.searchParams.set('login', 'required')
    return NextResponse.redirect(url)
  }

  return supabaseResponse
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
}
```

#### 2.4 OAuth 콜백 핸들러

```typescript
// app/auth/callback/route.ts
import { createClient } from '@/lib/supabase/server'
import { NextResponse } from 'next/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/board'

  if (code) {
    const supabase = await createClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)
    if (!error) {
      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  // 에러 시 홈으로
  return NextResponse.redirect(`${origin}/board?error=auth_failed`)
}
```

### Step 3: 인증 시스템
- `lib/supabase/client.ts` 생성 (브라우저)
- `lib/supabase/server.ts` 생성 (서버)
- `lib/supabase/admin.ts` 생성 (service_role)
- `middleware.ts` 생성 (세션 프록시)
- `app/auth/callback/route.ts` 생성 (OAuth 콜백)

### Step 3: API 라우트
- `app/api/board/posts/route.ts` (목록, 작성)
- `app/api/board/posts/[id]/route.ts` (상세, 수정, 삭제)
- `app/api/board/comments/route.ts` (댓글 작성)
- `app/api/board/comments/[id]/route.ts` (댓글 삭제)

### Step 4: UI 컴포넌트
- `components/board/AuthButton.tsx`
- `components/board/PostList.tsx`
- `components/board/PostForm.tsx`
- `components/board/CommentSection.tsx`

### Step 5: 페이지
- `app/board/page.tsx` (목록)
- `app/board/write/page.tsx` (작성)
- `app/board/[id]/page.tsx` (상세)

### Step 6: 네비게이션 연동
- 홈페이지에 게시판 링크 추가

---

## 4. 주요 참조 파일

| 파일 | 참조 내용 |
|------|----------|
| `lib/supabase.ts` | 기존 Supabase 클라이언트 패턴 |
| `app/api/feedback/route.ts` | API 라우트 패턴 |
| `components/skin-b/FeedbackModal.tsx` | Skin-B UI 스타일 |
| `app/home-b/page.tsx` | 페이지 레이아웃 |

---

## 5. 관리자 설정

구현 완료 후 Supabase SQL Editor에서 관리자 지정:

```sql
-- 카카오 ID로 관리자 지정
UPDATE public.profiles
SET is_admin = true
WHERE kakao_id = '카카오_고유_ID';
```

---

## 6. UI 디자인 가이드 (Skin-B)

### 색상
- 배경: `#FAFAF8` (크림 화이트)
- 테두리: `border-black` 또는 `border-gray-200`
- 강조: `bg-black text-white`

### 컴포넌트 스타일
```tsx
// 카드/박스
<div className="border-2 border-black bg-white p-4">

// 버튼 (Primary)
<button className="px-4 py-2 bg-black text-white font-bold hover:bg-gray-800">

// 버튼 (Secondary)
<button className="px-4 py-2 border border-black hover:bg-gray-100">

// 뱃지 (공지)
<span className="px-2 py-0.5 bg-black text-white text-[10px] font-bold">
  공지
</span>

// 뱃지 (관리자)
<span className="px-2 py-0.5 border border-black text-[10px]">
  관리자
</span>
```

---

## 7. API 명세

### 게시글 API

| Method | Endpoint | 설명 |
|--------|----------|------|
| GET | `/api/board/posts` | 게시글 목록 (페이지네이션) |
| POST | `/api/board/posts` | 게시글 작성 (인증 필요) |
| GET | `/api/board/posts/[id]` | 게시글 상세 |
| PUT | `/api/board/posts/[id]` | 게시글 수정 (작성자만) |
| DELETE | `/api/board/posts/[id]` | 게시글 삭제 (작성자만) |

### 댓글 API

| Method | Endpoint | 설명 |
|--------|----------|------|
| POST | `/api/board/comments` | 댓글 작성 (인증 필요) |
| DELETE | `/api/board/comments/[id]` | 댓글 삭제 (작성자만) |

### 요청/응답 예시

```typescript
// GET /api/board/posts?page=1
// Response
{
  posts: [
    {
      id: 1,
      title: "공지사항입니다",
      content: "...",
      is_notice: true,
      view_count: 42,
      created_at: "2026-01-06T10:00:00Z",
      author: {
        nickname: "관리자",
        profile_image: "...",
        is_admin: true
      },
      comment_count: 5
    }
  ],
  pagination: {
    page: 1,
    limit: 20,
    total: 100,
    totalPages: 5
  }
}

// POST /api/board/posts
// Request
{
  title: "제목",
  content: "내용",
  isNotice: false  // 관리자만 true 가능
}
```

---

## 8. 보안 및 스팸 방지

### 8.0 보안 리뷰 반영 사항 (Must-fix) ✅

| # | 취약점 | 해결 방법 | 상태 |
|---|--------|----------|------|
| 1 | Soft delete와 DELETE 정책 혼재 | DELETE 정책 제거, soft delete만 허용 | ✅ 반영됨 |
| 2 | RLS PERMISSIVE OR 이슈 (차단 정책 뚫림) | 차단 체크를 기존 INSERT/UPDATE에 통합 | ✅ 반영됨 |
| 3 | `is_admin` 임의 변경 가능 | 컬럼 권한으로 잠금 (`REVOKE UPDATE`) | ✅ 반영됨 |
| 4 | `increment_view_count` 클라이언트 조작 가능 | `search_path=''` + `service_role`만 실행 허용 | ✅ 반영됨 |
| 5 | `kakao_id` BIGINT 캐스팅 실패 가능 | TEXT로 변경 | ✅ 반영됨 |
| 6 | `handle_new_user()` 메타데이터 키 의존성 | 여러 키 fallback + EXCEPTION 핸들링 | ✅ 반영됨 |

### 8.0.1 Should-fix 항목 ✅

| # | 항목 | 설명 | 상태 |
|---|------|------|------|
| 7 | `updated_at` 자동 갱신 안됨 | BEFORE UPDATE 트리거 추가 (view_count 제외) | ✅ 반영됨 |
| 8 | 관리자가 글 숨김/삭제 불가 | UPDATE 정책에 관리자 OR 조건 추가 | ✅ 반영됨 |
| 9 | 인덱스 미비 | 복합 인덱스 + 부분 인덱스 추가 | ✅ 반영됨 |
| 10 | SSR 세션 프록시 누락 | middleware.ts에 updateSession 패턴 추가 | ✅ 반영됨 |
| 11 | `getSession()` 신뢰 이슈 | `getUser()`로 검증 (미들웨어 적용) | ✅ 반영됨 |

### 8.0.2 뷰 기반 쿼리 (Soft Delete 안전 패턴)

```typescript
// ✅ 권장: 뷰 사용
const { data } = await supabase.from('active_posts').select('*')
const { data } = await supabase.from('active_comments').select('*')

// ❌ 비권장: 테이블 직접 조회 (deleted_at 필터 필요)
const { data } = await supabase.from('posts').select('*').is('deleted_at', null)
```

### 8.0.3 조회수 증가 (service_role 전용)

```typescript
// API Route에서만 호출 (service_role 필요)
// lib/supabase/admin.ts의 createAdminClient() 사용

import { createAdminClient } from '@/lib/supabase/admin'

export async function GET(request: Request, { params }: { params: { id: string } }) {
  const adminClient = createAdminClient()

  // service_role만 실행 가능
  await adminClient.rpc('increment_view_count', { p_post_id: parseInt(params.id) })

  // ... 나머지 로직
}
```

### 8.1 입력값 검증 (서버 사이드)

```typescript
// 제목/내용 길이 제한
const LIMITS = {
  title: { min: 2, max: 100 },
  content: { min: 10, max: 10000 },
  comment: { min: 1, max: 1000 },
}

// HTML 태그 제거 (XSS 방지)
const sanitize = (text: string) => text.replace(/<[^>]*>/g, '')
```

### 8.2 Rate Limiting (API 호출 제한)

```typescript
// 사용자별 제한 (Supabase Edge Function 또는 미들웨어)
const RATE_LIMITS = {
  posts: { max: 5, window: '1h' },      // 시간당 게시글 5개
  comments: { max: 20, window: '1h' },  // 시간당 댓글 20개
}
```

### 8.3 스팸 방지

| 방법 | 설명 | 구현 |
|------|------|------|
| 연속 작성 제한 | 같은 내용 연속 등록 방지 | 최근 게시글과 내용 비교 |
| 시간 제한 | 연속 작성 간격 제한 (30초) | created_at 비교 |
| 금칙어 필터 | 욕설/광고 키워드 차단 | 키워드 목록 체크 |
| 링크 제한 | 신규 사용자 링크 포함 제한 | URL 패턴 감지 |

### 8.4 관리자 기능

```sql
-- 사용자 차단 테이블
CREATE TABLE public.blocked_users (
  id SERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id),
  reason TEXT,
  blocked_at TIMESTAMPTZ DEFAULT NOW(),
  blocked_until TIMESTAMPTZ  -- NULL이면 영구 차단
);

-- 게시글 신고 테이블
CREATE TABLE public.reports (
  id SERIAL PRIMARY KEY,
  reporter_id UUID NOT NULL REFERENCES public.profiles(id),
  post_id INTEGER REFERENCES public.posts(id),
  comment_id INTEGER REFERENCES public.comments(id),
  reason TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

### 8.5 RLS 정책 요약

> ⚠️ **중요**: 차단 정책을 별도로 추가하면 안 됩니다!
> PostgreSQL RLS는 같은 커맨드에 정책이 여러 개면 **OR로 결합**됩니다.
> 차단 체크는 기존 INSERT/UPDATE 정책에 통합되어 있습니다. (섹션 1.2 참조)

```sql
-- ❌ 이렇게 하면 안 됨 (기존 정책과 OR되어 차단 우회 가능)
CREATE POLICY "posts_insert_not_blocked" ON public.posts
FOR INSERT WITH CHECK (...);

-- ✅ 이미 posts_insert에 차단 체크가 통합됨
-- 섹션 1.2의 SQL 참조
```

### 8.6 보안 구현 목록

#### 자동 처리 (프레임워크/라이브러리 제공)
| 항목 | 처리 방식 |
|------|----------|
| CSRF 토큰 검증 | Next.js 기본 제공 |
| SQL Injection 방지 | Supabase SDK 파라미터 바인딩 |
| 기본 XSS 방지 | React JSX 자동 이스케이프 |

#### 직접 구현 필요
| 항목 | 구현 위치 | 설명 |
|------|----------|------|
| 입력값 sanitize | `lib/board/validation.ts` | HTML 태그 제거, 길이 검증 |
| 인증 토큰 검증 | API 라우트 | 모든 POST/PUT/DELETE에서 세션 체크 |
| 권한 검증 | API 라우트 + RLS | 공지글: 관리자만, 수정/삭제: 작성자만 |
| Rate Limiting | 미들웨어 또는 API | 시간당 작성 횟수 제한 |
| 스팸 필터 | `lib/board/spam-filter.ts` | 금칙어, 연속 작성, 링크 제한 |
| 차단 사용자 체크 | RLS + API | blocked_users 테이블 조회 |

#### 구현 체크리스트
- [ ] `lib/board/validation.ts` - sanitize 함수, 길이 검증
- [ ] `lib/board/spam-filter.ts` - 금칙어 목록, 스팸 판정 로직
- [ ] API 라우트에 인증/권한 미들웨어 적용
- [ ] Rate Limiting 미들웨어 (또는 Supabase Edge Function)
- [ ] 신고 기능 UI 및 API

---

## 9. 추가 개선 사항

### 9.1 SEO 및 소셜 공유

게시글이 카카오톡/SNS에 공유될 때 OG 메타데이터 필요:

```typescript
// app/board/[id]/page.tsx
import { Metadata } from 'next'

export async function generateMetadata({ params }: { params: { id: string } }): Promise<Metadata> {
  const post = await getPost(params.id)

  return {
    title: `${post.title} | OpenRisk 게시판`,
    description: post.content.slice(0, 100),
    openGraph: {
      title: post.title,
      description: post.content.slice(0, 100),
      type: 'article',
      publishedTime: post.created_at,
      authors: [post.author.nickname],
    },
  }
}
```

### 9.2 조회수 중복 방지

24시간 내 동일 글 재조회 시 조회수 증가 방지:

```typescript
// lib/board/view-tracker.ts
const VIEWED_KEY = 'openrisk_viewed_posts'
const EXPIRE_HOURS = 24

export function shouldCountView(postId: number): boolean {
  const viewed = JSON.parse(localStorage.getItem(VIEWED_KEY) || '{}')
  const now = Date.now()

  // 만료된 항목 정리
  Object.keys(viewed).forEach(key => {
    if (now - viewed[key] > EXPIRE_HOURS * 60 * 60 * 1000) {
      delete viewed[key]
    }
  })

  if (viewed[postId]) return false

  viewed[postId] = now
  localStorage.setItem(VIEWED_KEY, JSON.stringify(viewed))
  return true
}
```

### 9.3 Soft Delete (삭제 정책)

데이터 복구 가능성을 위해 실제 삭제 대신 `deleted_at` 사용:
- 테이블 정의에 `deleted_at TIMESTAMPTZ DEFAULT NULL` 컬럼 포함됨
- RLS 정책에서 `deleted_at IS NULL` 조건으로 삭제된 글 필터링
- 삭제 시 `DELETE` 대신 `UPDATE SET deleted_at = NOW()` 실행

```typescript
// API에서 삭제 처리
async function deletePost(postId: number) {
  await supabase
    .from('posts')
    .update({ deleted_at: new Date().toISOString() })
    .eq('id', postId)
}
```

### 9.4 관리자 조건부 렌더링

관리자에게만 보이는 기능:

```tsx
// 게시글 상세 페이지에서
{isAdmin && (
  <div className="flex gap-2 border-t border-gray-200 pt-3 mt-3">
    <button className="text-xs text-red-500 hover:underline">
      이 글 숨기기
    </button>
    <button className="text-xs text-red-500 hover:underline">
      작성자 차단
    </button>
    <Link href="/admin/reports" className="text-xs text-gray-500 hover:underline">
      신고 목록
    </Link>
  </div>
)}
```

### 9.5 페이지네이션 방식

| 방식 | 장점 | 단점 | 결정 |
|------|------|------|------|
| Offset | 구현 간단, 페이지 번호 표시 가능 | 대용량에서 성능 저하 | **현재 채택** |
| Cursor | 대용량에서 성능 우수 | 페이지 번호 표시 어려움 | 추후 고려 |

현재 규모에서는 offset 방식으로 충분. 트래픽 증가 시 cursor 방식으로 전환.

---

## 10. 예상 작업량

| 단계 | 작업 내용 | 파일 수 |
|------|----------|---------|
| Supabase 설정 | OAuth + DB 테이블 | - |
| 인증 시스템 | auth 클라이언트 + 콜백 | 2 |
| API 라우트 | posts + comments CRUD | 4 |
| UI 컴포넌트 | 게시판 관련 | 4 |
| 페이지 | 목록 + 상세 + 작성 | 3 |
| **합계** | | **13개 파일** |
